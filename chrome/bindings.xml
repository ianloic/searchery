<?xml version="1.0"?>

<bindings id="searcheryBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="autocomplete-rich-result-popup"
           extends="chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup">
    <content ignorekeys="true">
      <xul:vbox anonid="searchery-sections">
        <xul:vbox class="searchery-section-places" selected="true"
                  title="History and Bookmarks">
          <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox"
              flex="1"/>
        </xul:vbox>
        <xul:vbox class="searchery-section" title="Search Engines" id="searchery-engines" />
        <xul:vbox class="searchery-section" title="Google Results" id="searchery-google" />
        <xul:vbox class="searchery-section" title="Amazon Results" id="searchery-amazon" />
      </xul:vbox>
    </content>

    <implementation implements="nsIAutoCompletePopup">
      <constructor><![CDATA[
        this._sections = document.getAnonymousElementByAttribute(this,
            'anonid', 'searchery-sections').childNodes;
        
        var self = this;
        // these listeners are attached to the input when they can be
        this._inputListener = function (event) {
          self.newSearch();
        }
        this._keypressListener = function (event) {
          dump('keypress: '+event.keyCode+'\n');
          if (event.keyCode == 13) {
            if (self._section) {
              event.preventDefault();
              event.stopPropagation();
              var item = self._sections[self._section].richlistbox.selectedItem;
              var url = item.getAttribute('url');
              self.input.textValue = url;
              handleURLBarCommand(event);
              self.reallyClosePopup();
            }
          } else if (event.keyCode == 27) {
            self.reallyClosePopup();
          }
        }
      ]]></constructor>
      <field name="_section">0</field>
      <method name="selectBy">
        <parameter name="aReverse"/>
        <parameter name="aPage"/>
        <body>
          <![CDATA[
          /* this is called by the controller when the arrow or page keys are
             pressed. it must be subverted for our nefarious purposes */
          try {
            if (aPage) {
              // page up/down means switch section
              this._section += (aReverse?-1:1);
              if (this._section < 0 || this._section >= this._sections.length) {
                this.input._focus();
                this._section = 0;
              }
              dump('this._section = '+this._section+'\n');

              dump(' sections.length: '+this._sections.length+'\n');
              for (var i=0; i<this._sections.length; i++) {
                // mark the selected section as selected
                this._sections[i].selected = (i == this._section);
              }
            } else {
              if (this._section == 0) {
                // the places section
                this.selectedIndex = this.getNextIndex(aReverse, 1,
                    this.selectedIndex, this._matchCount - 1);
                if (this.selectedIndex == -1) {
                  this.input._focus();
                }
              } else {
                // a searchery section
                this._sections[this._section].selectBy(aReverse);
              }
            }
          } catch (ex) {
            Components.utils.reportError(ex);
          }
            ]]>
        </body>
      </method>

      <field name="_lastQuery">null</field>
      <method name="newSearch">
        <body><![CDATA[
          try {
            var query = this.input.controller.searchString;

            if (query === this._lastQuery) {
              return;
            }

            this._lastQuery = query;

            // make sure the popup is open
            this.input.popupOpen = true;

            dump('newSearch: '+query+'\n');
            for (var i=0; i<this._sections.length; i++) {
              try {
                this._sections[i].newSearch(query);
              } catch(e) {
                Components.utils.reportError(e);
              }
            }
          } catch(e) {
          Components.utils.reportError(e);
        }
        ]]></body>
      </method>

      <method name="closePopup">
        <body>
          <![CDATA[
        ]]>
        </body>
      </method>
      <method name="reallyClosePopup">
        <body>
          <![CDATA[
          if (this.mPopupOpen) {
            this.hidePopup();
            document.popupNode = null;
            this.removeAttribute("width");
          }
        ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="popupshowing"><![CDATA[
        this.newSearch();
        this.input.addEventListener('input', this._inputListener, false);
        this.input.addEventListener('keypress', this._keypressListener, true);
      ]]></handler>
      <handler event="popuphiding"><![CDATA[
        this.input.removeEventListener('input', this._inputListner, false);
        this.input.removeEventListener('keypress', this._keypressListner, true);
      ]]></handler>
    </handlers>
  </binding>

  <binding id="base-section" extends="xul:vbox">
    <content>
      <xul:hbox>
        <xul:image class="searchery-disclosure-triangle" state="open"/>
        <xul:label class="searchery-section-header" xbl:inherits="value=title"/>
        <xul:spacer flex="1"/>
        <xul:image class="searchery-section-spinner"/>
      </xul:hbox>
      <children/>
    </content>
    <implementation>
      <property name="loading">
        <setter><![CDATA[
          if (val) {
            this.setAttribute('loading', 'true');
          } else {
            this.removeAttribute('loading');
          }
        ]]></setter>
      </property>
      <method name="newSearch">
        <parameter name="query"/>
        <!-- implemented by subclasses as appropriate -->
        <body></body>
      </method>
    </implementation>
  </binding>

  <binding id="places-section" extends="#base-section">
    <implementation>
      <method name="onPopupClick">
        <parameter name="event" />
        <body><![CDATA[
          // pass this up one binding...
          return this.parentNode.parentNode.onPopupClick(event);
        ]]></body>
      </method>

      <property name="selected">
        <getter><![CDATA[
          return this.hasAttribute('selected');
        ]]></getter>
        <setter><![CDATA[
          if (val) {
            this.setAttribute('selected', 'true');
            //this.richlistbox.selectedIndex = 0;
          } else {
            this.removeAttribute('selected');
            //this.richlistbox.selectedIndex = -1;
          }
        ]]></setter>
      </property>
    </implementation>
  </binding>

  <binding id="section" extends="#base-section">
    <implementation>
      <field name="richlistbox">null</field>
      <field name="lastQuery">''</field>
      <constructor><![CDATA[
        this.richlistbox = document.createElement('richlistbox');
        this.richlistbox.className = 'autocomplete-richlistbox searchery-richlistbox';
        this.richlistbox.setAttribute('flex', '1');
        this.appendChild(richlistbox);

        this.popup = this.parentNode.parentNode;
      ]]></constructor>

      <property name="disabled">
        <getter><![CDATA[
          return this.hasAttribute('disabled');
        ]]></getter>
        <setter><![CDATA[
          if (val) {
            this.setAttribute('disabled', 'true');
          } else {
            this.removeAttribute('disabled');
          }
        ]]></setter>
      </property>
      <method name="onPopupClick">
        <parameter name="event" />
        <body><![CDATA[
          // pass this up one binding...
          var item = this.richlistbox.selectedItem;
          var url = item.getAttribute('url');
          this.popup.reallyClosePopup();
          this.popup.input.textValue = url;
          handleURLBarCommand(event);
        ]]></body>
      </method>

      <method name="selectBy">
        <parameter name="aReverse"/>
        <body><![CDATA[
          dump('selectBy!!!!\n');
          var newIndex = this.richlistbox.selectedIndex +
              (aReverse?-1:1);
          if (newIndex < 0) {
            newIndex = 0;
          }
          if (newIndex >= this.richlistbox.itemCount) {
            newIndex = this.richlistbox.itemCount-1;
          }
          this.richlistbox.selectedIndex = newIndex;
        ]]></body>
      </method>
      <property name="selected">
        <getter><![CDATA[
          return this.hasAttribute('selected');
        ]]></getter>
        <setter><![CDATA[
          if (val) {
            this.setAttribute('selected', 'true');
            this.richlistbox.selectedIndex = 0;
          } else {
            this.removeAttribute('selected');
            this.richlistbox.selectedIndex = -1;
          }
        ]]></setter>
      </property>

      <method name="clearResults">
        <body><![CDATA[
          // clear the richlistbox
          while(this.richlistbox.firstChild) {
            this.richlistbox.removeChild(this.richlistbox.firstChild);
          }
        ]]></body>
      </method>
      <method name="addResult">
        <parameter name="uri"/>
        <parameter name="title"/>
        <parameter name="image"/>
        <parameter name="cssClass"/>
        <body><![CDATA[
          // trim the leading/trailing whitespace
          var trimmedSearchString =
              this.lastQuery.replace(/^\s+/, "").replace(/\s+$/, "");

          // need to create a new item
          var item = document.createElement("richlistitem");

          // set these attributes before we set the class
          // so that we can use them from the contructor
          item.setAttribute("image", image);
          item.setAttribute("url", uri);
          item.setAttribute("title", title);
          item.setAttribute("type", cssClass);
          item.setAttribute("text", trimmedSearchString);
          item.className = "autocomplete-richlistitem";
          this.richlistbox.appendChild(item);
        ]]></body>
      </method>
      <method name="newSearch">
        <parameter name="query"/>
        <body><![CDATA[
          // do stuff
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="DisclosureChanged"><![CDATA[
        dump('disclosure changed\n');
        dump(' open='+event.originalTarget.open+'\n');
        this.disabled = !event.originalTarget.open;
      ]]></handler>
    </handlers>
  </binding>

  <binding id="engines-section" extends="#section">
    <implementation>
      <method name="newSearch">
        <parameter name="query"/>
        <body><![CDATA[
          // save the query
          // FIXME: refactor this into a baseclass somehow
          this.lastQuery = query;

          dump('engines newSearch\n');
          // make sure we have a reference to the search service
          if (!this._searchService) {
            this._searchService =
                Components.classes['@mozilla.org/browser/search-service;1']
                .getService(Components.interfaces.nsIBrowserSearchService);
          }

          // clear the richlistbox
          this.clearResults();

          // fill it with search engines...
          var engines = this._searchService.getVisibleEngines({ });
          for (var i=0; i<engines.length; i++) {
            var submission = engines[i].getSubmission(query, 'text/html');
            this.addResult(submission.uri.spec,
                'Search for "'+query+'" on '+engines[i].name,
                engines[i].iconURI.spec,
                'suggesthint searchery srch-searchengines');
          }

        ]]></body>
      </method>
      -->

    </implementation>

  </binding>

  <binding id="disclosure-triangle" extends="xul:image">
    <implementation>
      <property name="state">
        <getter><![CDATA[
          return this.getAttribute('state');
        ]]></getter>
        <setter><![CDATA[
          this.setAttribute('state', val);
          var event = document.createEvent('Event');
          event.initEvent('DisclosureChanged', true, true);
          this.dispatchEvent(event);
        ]]></setter>
      </property>
      <property name="open">
        <getter><![CDATA[
          return this.state === 'open';
        ]]></getter>
        <setter><![CDATA[
          this.state = val?'open':'closed';
        ]]></setter>
      </property>
    </implementation>
    <handlers>
      <handler event="click">
        this.open = !this.open;
      </handler>
    </handlers>
  </binding>
</bindings>
